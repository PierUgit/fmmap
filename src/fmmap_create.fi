   integer(fmmap_size_t), intent(in)         :: shape(:) 
      !! shape of the pointer
      !! - `size(shape)` must be equal to the rank of `p`
      !! - With `FMMAP_FILE_OLD` the last element of `shape` can be negative. In this case,
      !!   the size of the last dimension of `p` is determined from the file size. This is
      !!   the recommended method.
   integer,             intent(in)           :: filemode 
      !! FILE_SCRATCH, FILE_OLD, or FILE_NEW
   character(*),        intent(in), optional :: filename
     !! FILE_OLD or FILE_new: required name of the file (with or without path)
     !! FILE_SCRATCH: name of the path; not required;
     !! - if not present:
     !!   - POSIX: is "." (current directory) by default
     !!   - WIN32: the Windows temporary path is inquired     
     !! - a processor dependent unique filename is be generated
   integer(fmmap_size_t), intent(in), optional :: lower(:)
      !! lower bounds of the output pointer;
      !! the size of `lower` must be equal to the rank of `p`
   logical,               intent(in), optional :: copyonwrite
      !! if .true., all the changes made to the mapped file stay only in memory
      !! and are not written back to the file.
      
   integer, parameter :: ss = storage_size(q)
   type(c_ptr) :: cptr
   integer(fmmap_size_t) :: nbytes, n
   integer(fmmap_size_t), allocatable :: sh(:), lb(:), ub(:)
   !********************************************************************************************
   
   if (rank(p) < 1 .or. rank(p) > 7) error stop msg0//msg1
   if (size(shape) /= rank(p)  ) error stop msg0//msg2
   if (any(shape(1:rank(p)-1) < 0)) error stop msg0//msg4
   if (shape(rank(p)) < 0 .and. filemode /= FMMAP_OLD) error stop msg0//msg5
   
   sh = shape
   if (filemode /= FMMAP_OLD) then
      nbytes = fmmap_nbytes( product(sh), ss )
   end if
      
   call fmmap_create(cptr,nbytes,filemode,filename,copyonwrite)

   if (filemode == FMMAP_OLD) then
      n = fmmap_nelems(nbytes, ss )
      if (sh(rank(p)) < 0) sh(rank(p)) = n / product( sh(1:rank(p)-1) )
      if (product( sh ) /= n) error stop msg0//msg3 
   end if
   allocate( lb(rank(p)), source=1_fmmap_size_t )
   if (present(lower)) lb = lower
   ub = lb + sh - 1
   
   call c_f_pointer( cptr, q, [product( sh )] )
   select rank(p)
      rank(1) ; p( lb(1):ub(1) ) => q
      rank(2) ; p( lb(1):ub(1) &
                 , lb(2):ub(2) ) => q
      rank(3) ; p( lb(1):ub(1) &
                 , lb(2):ub(2) &
                 , lb(3):ub(3) ) => q
      rank(4) ; p( lb(1):ub(1) &
                 , lb(2):ub(2) &
                 , lb(3):ub(3) &
                 , lb(4):ub(4) ) => q
      rank(5) ; p( lb(1):ub(1) &
                 , lb(2):ub(2) &
                 , lb(3):ub(3) &
                 , lb(4):ub(4) &
                 , lb(5):ub(5) ) => q
      rank(6) ; p( lb(1):ub(1) &
                 , lb(2):ub(2) &
                 , lb(3):ub(3) &
                 , lb(4):ub(4) &
                 , lb(5):ub(5) &
                 , lb(6):ub(6) ) => q
      rank(7) ; p( lb(1):ub(1) &
                 , lb(2):ub(2) &
                 , lb(3):ub(3) &
                 , lb(4):ub(4) &
                 , lb(5):ub(5) &
                 , lb(6):ub(6) &
                 , lb(7):ub(7) ) => q
   end select
   